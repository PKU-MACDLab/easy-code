# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _cffirmware
else:
    import _cffirmware

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


M_PI_F = _cffirmware.M_PI_F
M_1_PI_F = _cffirmware.M_1_PI_F
M_PI_2_F = _cffirmware.M_PI_2_F

def fsqr(x):
    return _cffirmware.fsqr(x)

def radians(degrees):
    return _cffirmware.radians(degrees)

def degrees(radians):
    return _cffirmware.degrees(radians)

def clamp(value, min, max):
    return _cffirmware.clamp(value, min, max)
class vec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_cffirmware.vec_x_get, _cffirmware.vec_x_set)
    y = property(_cffirmware.vec_y_get, _cffirmware.vec_y_set)
    z = property(_cffirmware.vec_z_get, _cffirmware.vec_z_set)

    def __repr__(self):
        return "({}, {}, {})".format(self.x, self.y, self.z)

    def __array__(self):
        return np.array([self.x, self.y, self.z])

    def __len__(self):
        return 3

    def __getitem__(self, i):
        if 0 <= i and i < 3:
            return _cffirmware.vindex(self, i)
        else:
            raise IndexError("vec index must be in {0, 1, 2}.")

    # Unary operator overloads.
    def __neg__(self):
        return _cffirmware.vneg(self)

    # Vector-scalar binary operator overloads.
    def __rmul__(self, s):
        return _cffirmware.vscl(s, self)

    def __div__(self, s):
        return self.__truediv__(s)

    def __truediv__(self, s):
        return _cffirmware.vdiv(self, s)

    # Vector-vector binary operator overloads.
    def __add__(self, other):
        return _cffirmware.vadd(self, other)

    def __sub__(self, other):
        return _cffirmware.vsub(self, other)


    def __init__(self):
        _cffirmware.vec_swiginit(self, _cffirmware.new_vec())
    __swig_destroy__ = _cffirmware.delete_vec

# Register vec in _cffirmware:
_cffirmware.vec_swigregister(vec)


def mkvec(x, y, z):
    return _cffirmware.mkvec(x, y, z)

def vrepeat(x):
    return _cffirmware.vrepeat(x)

def vzero():
    return _cffirmware.vzero()

def vscl(s, v):
    return _cffirmware.vscl(s, v)

def vneg(v):
    return _cffirmware.vneg(v)

def vdiv(v, s):
    return _cffirmware.vdiv(v, s)

def vadd(a, b):
    return _cffirmware.vadd(a, b)

def vsub(a, b):
    return _cffirmware.vsub(a, b)

def vdot(a, b):
    return _cffirmware.vdot(a, b)

def veltmul(a, b):
    return _cffirmware.veltmul(a, b)

def veltdiv(a, b):
    return _cffirmware.veltdiv(a, b)

def veltrecip(a):
    return _cffirmware.veltrecip(a)

def vmag2(v):
    return _cffirmware.vmag2(v)

def vmag(v):
    return _cffirmware.vmag(v)

def vdist2(a, b):
    return _cffirmware.vdist2(a, b)

def vdist(a, b):
    return _cffirmware.vdist(a, b)

def vnormalize(v):
    return _cffirmware.vnormalize(v)

def vcross(a, b):
    return _cffirmware.vcross(a, b)

def vprojectunit(a, b_unit):
    return _cffirmware.vprojectunit(a, b_unit)

def vorthunit(a, b_unit):
    return _cffirmware.vorthunit(a, b_unit)

def vabs(v):
    return _cffirmware.vabs(v)

def vmin(a, b):
    return _cffirmware.vmin(a, b)

def vmax(a, b):
    return _cffirmware.vmax(a, b)

def vclamp(v, lower, upper):
    return _cffirmware.vclamp(v, lower, upper)

def vclampabs(v, abs_upper):
    return _cffirmware.vclampabs(v, abs_upper)

def vmaxelt(v):
    return _cffirmware.vmaxelt(v)

def vminelt(v):
    return _cffirmware.vminelt(v)

def vnorm1(v):
    return _cffirmware.vnorm1(v)

def veq(a, b):
    return _cffirmware.veq(a, b)

def vneq(a, b):
    return _cffirmware.vneq(a, b)

def veqepsilon(a, b, epsilon):
    return _cffirmware.veqepsilon(a, b, epsilon)

def vless(a, b):
    return _cffirmware.vless(a, b)

def vleq(a, b):
    return _cffirmware.vleq(a, b)

def vgreater(a, b):
    return _cffirmware.vgreater(a, b)

def vgeq(a, b):
    return _cffirmware.vgeq(a, b)

def visnan(v):
    return _cffirmware.visnan(v)

def vadd3(a, b, c):
    return _cffirmware.vadd3(a, b, c)

def vadd4(a, b, c, d):
    return _cffirmware.vadd4(a, b, c, d)

def vsub2(a, b, c):
    return _cffirmware.vsub2(a, b, c)

def vload(d):
    return _cffirmware.vload(d)

def vstore(v, d):
    return _cffirmware.vstore(v, d)

def vloadf(f):
    return _cffirmware.vloadf(f)

def vstoref(v, f):
    return _cffirmware.vstoref(v, f)

def vindex(v, i):
    return _cffirmware.vindex(v, i)
class mat33(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m = property(_cffirmware.mat33_m_get, _cffirmware.mat33_m_set)

    def __init__(self):
        _cffirmware.mat33_swiginit(self, _cffirmware.new_mat33())
    __swig_destroy__ = _cffirmware.delete_mat33

# Register mat33 in _cffirmware:
_cffirmware.mat33_swigregister(mat33)


def mzero():
    return _cffirmware.mzero()

def mdiag(a, b, c):
    return _cffirmware.mdiag(a, b, c)

def meyescl(a):
    return _cffirmware.meyescl(a)

def meye():
    return _cffirmware.meye()

def mcolumns(a, b, c):
    return _cffirmware.mcolumns(a, b, c)

def mrows(a, b, c):
    return _cffirmware.mrows(a, b, c)

def mcrossmat(v):
    return _cffirmware.mcrossmat(v)

def mcolumn(m, col):
    return _cffirmware.mcolumn(m, col)

def mrow(m, row):
    return _cffirmware.mrow(m, row)

def mtranspose(m):
    return _cffirmware.mtranspose(m)

def mscl(s, a):
    return _cffirmware.mscl(s, a)

def mneg(a):
    return _cffirmware.mneg(a)

def madd(a, b):
    return _cffirmware.madd(a, b)

def msub(a, b):
    return _cffirmware.msub(a, b)

def mvmul(a, v):
    return _cffirmware.mvmul(a, v)

def mmul(a, b):
    return _cffirmware.mmul(a, b)

def maddridge(a, d):
    return _cffirmware.maddridge(a, d)

def misnan(m):
    return _cffirmware.misnan(m)

def set_block33_rowmaj(block, stride, m):
    return _cffirmware.set_block33_rowmaj(block, stride, m)

def madd3(a, b, c):
    return _cffirmware.madd3(a, b, c)

def maxisangle(axis, angle):
    return _cffirmware.maxisangle(axis, angle)

def mrotx(angle):
    return _cffirmware.mrotx(angle)

def mroty(angle):
    return _cffirmware.mroty(angle)

def mrotz(angle):
    return _cffirmware.mrotz(angle)
class quat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_cffirmware.quat_x_get, _cffirmware.quat_x_set)
    y = property(_cffirmware.quat_y_get, _cffirmware.quat_y_set)
    z = property(_cffirmware.quat_z_get, _cffirmware.quat_z_set)
    w = property(_cffirmware.quat_w_get, _cffirmware.quat_w_set)

    def __init__(self):
        _cffirmware.quat_swiginit(self, _cffirmware.new_quat())
    __swig_destroy__ = _cffirmware.delete_quat

# Register quat in _cffirmware:
_cffirmware.quat_swigregister(quat)


def mkquat(x, y, z, w):
    return _cffirmware.mkquat(x, y, z, w)

def quatvw(v, w):
    return _cffirmware.quatvw(v, w)

def qeye():
    return _cffirmware.qeye()

def qaxisangle(axis, angle):
    return _cffirmware.qaxisangle(axis, angle)

def qnormalize(q):
    return _cffirmware.qnormalize(q)

def qvectovec(a, b):
    return _cffirmware.qvectovec(a, b)

def rpy2quat(rpy):
    return _cffirmware.rpy2quat(rpy)

def rpy2quat_small(rpy):
    return _cffirmware.rpy2quat_small(rpy)

def mat2quat(m):
    return _cffirmware.mat2quat(m)

def quat2rpy(q):
    return _cffirmware.quat2rpy(q)

def quat2axis(q):
    return _cffirmware.quat2axis(q)

def quat2angle(q):
    return _cffirmware.quat2angle(q)

def quatimagpart(q):
    return _cffirmware.quatimagpart(q)

def quat2rotmat(q):
    return _cffirmware.quat2rotmat(q)

def qvrot(q, v):
    return _cffirmware.qvrot(q, v)

def qqmul(q, p):
    return _cffirmware.qqmul(q, p)

def qinv(q):
    return _cffirmware.qinv(q)

def qneg(q):
    return _cffirmware.qneg(q)

def qposreal(q):
    return _cffirmware.qposreal(q)

def qdot(a, b):
    return _cffirmware.qdot(a, b)

def qanglebetween(a, b):
    return _cffirmware.qanglebetween(a, b)

def qeq(a, b):
    return _cffirmware.qeq(a, b)

def quat_gyro_update(quat, gyro, dt):
    return _cffirmware.quat_gyro_update(quat, gyro, dt)

def qnlerp(a, b, t):
    return _cffirmware.qnlerp(a, b, t)

def qslerp(a, b, t):
    return _cffirmware.qslerp(a, b, t)

def qload(d):
    return _cffirmware.qload(d)

def qstore(q, d):
    return _cffirmware.qstore(q, d)

def qloadf(f):
    return _cffirmware.qloadf(f)

def qstoref(q, f):
    return _cffirmware.qstoref(q, f)
PP_DEGREE = _cffirmware.PP_DEGREE
PP_SIZE = _cffirmware.PP_SIZE

def polyval(p, t):
    return _cffirmware.polyval(p, t)

def polylinear(p, duration, x0, x1):
    return _cffirmware.polylinear(p, duration, x0, x1)

def polybezier(p, duration, x, dim):
    return _cffirmware.polybezier(p, duration, x, dim)

def poly5(poly, T, x0, dx0, ddx0, xf, dxf, ddxf):
    return _cffirmware.poly5(poly, T, x0, dx0, ddx0, xf, dxf, ddxf)

def polyscale(p, s):
    return _cffirmware.polyscale(p, s)

def polyder(p):
    return _cffirmware.polyder(p)

def polystretchtime(p, s):
    return _cffirmware.polystretchtime(p, s)

def polyreflect(p):
    return _cffirmware.polyreflect(p)
class poly4d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    p = property(_cffirmware.poly4d_p_get, _cffirmware.poly4d_p_set)
    duration = property(_cffirmware.poly4d_duration_get, _cffirmware.poly4d_duration_set)

    def __init__(self):
        _cffirmware.poly4d_swiginit(self, _cffirmware.new_poly4d())
    __swig_destroy__ = _cffirmware.delete_poly4d

# Register poly4d in _cffirmware:
_cffirmware.poly4d_swigregister(poly4d)


def poly4d_zero(duration):
    return _cffirmware.poly4d_zero(duration)

def poly4d_linear(duration, p0, p1, yaw0, yaw1):
    return _cffirmware.poly4d_linear(duration, p0, p1, yaw0, yaw1)

def poly4d_scale(p, x, y, z, yaw):
    return _cffirmware.poly4d_scale(p, x, y, z, yaw)

def poly4d_shift(p, x, y, z, yaw):
    return _cffirmware.poly4d_shift(p, x, y, z, yaw)

def poly4d_shift_vec(p, pos, yaw):
    return _cffirmware.poly4d_shift_vec(p, pos, yaw)

def poly4d_stretchtime(p, s):
    return _cffirmware.poly4d_stretchtime(p, s)

def polyder4d(p):
    return _cffirmware.polyder4d(p)

def poly4d_max_accel_approx(p):
    return _cffirmware.poly4d_max_accel_approx(p)
class traj_eval(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pos = property(_cffirmware.traj_eval_pos_get, _cffirmware.traj_eval_pos_set)
    vel = property(_cffirmware.traj_eval_vel_get, _cffirmware.traj_eval_vel_set)
    acc = property(_cffirmware.traj_eval_acc_get, _cffirmware.traj_eval_acc_set)
    omega = property(_cffirmware.traj_eval_omega_get, _cffirmware.traj_eval_omega_set)
    yaw = property(_cffirmware.traj_eval_yaw_get, _cffirmware.traj_eval_yaw_set)

    def __init__(self):
        _cffirmware.traj_eval_swiginit(self, _cffirmware.new_traj_eval())
    __swig_destroy__ = _cffirmware.delete_traj_eval

# Register traj_eval in _cffirmware:
_cffirmware.traj_eval_swigregister(traj_eval)


def traj_eval_zero():
    return _cffirmware.traj_eval_zero()

def traj_eval_invalid():
    return _cffirmware.traj_eval_invalid()

def is_traj_eval_valid(ev):
    return _cffirmware.is_traj_eval_valid(ev)

def poly4d_eval(p, t):
    return _cffirmware.poly4d_eval(p, t)
class piecewise_traj(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    t_begin = property(_cffirmware.piecewise_traj_t_begin_get, _cffirmware.piecewise_traj_t_begin_set)
    timescale = property(_cffirmware.piecewise_traj_timescale_get, _cffirmware.piecewise_traj_timescale_set)
    shift = property(_cffirmware.piecewise_traj_shift_get, _cffirmware.piecewise_traj_shift_set)
    n_pieces = property(_cffirmware.piecewise_traj_n_pieces_get, _cffirmware.piecewise_traj_n_pieces_set)
    pieces = property(_cffirmware.piecewise_traj_pieces_get, _cffirmware.piecewise_traj_pieces_set)

    def __init__(self):
        _cffirmware.piecewise_traj_swiginit(self, _cffirmware.new_piecewise_traj())
    __swig_destroy__ = _cffirmware.delete_piecewise_traj

# Register piecewise_traj in _cffirmware:
_cffirmware.piecewise_traj_swigregister(piecewise_traj)


def piecewise_duration(pp):
    return _cffirmware.piecewise_duration(pp)

def piecewise_plan_5th_order(p, duration, p0, y0, v0, dy0, a0, p1, y1, v1, dy1, a1):
    return _cffirmware.piecewise_plan_5th_order(p, duration, p0, y0, v0, dy0, a0, p1, y1, v1, dy1, a1)

def piecewise_plan_7th_order_no_jerk(p, duration, p0, y0, v0, dy0, a0, p1, y1, v1, dy1, a1):
    return _cffirmware.piecewise_plan_7th_order_no_jerk(p, duration, p0, y0, v0, dy0, a0, p1, y1, v1, dy1, a1)

def piecewise_eval(traj, t):
    return _cffirmware.piecewise_eval(traj, t)

def piecewise_eval_reversed(traj, t):
    return _cffirmware.piecewise_eval_reversed(traj, t)

def piecewise_is_finished(traj, t):
    return _cffirmware.piecewise_is_finished(traj, t)
TRAJECTORY_STATE_IDLE = _cffirmware.TRAJECTORY_STATE_IDLE
TRAJECTORY_STATE_FLYING = _cffirmware.TRAJECTORY_STATE_FLYING
TRAJECTORY_STATE_LANDING = _cffirmware.TRAJECTORY_STATE_LANDING
TRAJECTORY_TYPE_PIECEWISE = _cffirmware.TRAJECTORY_TYPE_PIECEWISE
TRAJECTORY_TYPE_PIECEWISE_COMPRESSED = _cffirmware.TRAJECTORY_TYPE_PIECEWISE_COMPRESSED
class planner(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    state = property(_cffirmware.planner_state_get, _cffirmware.planner_state_set)
    type = property(_cffirmware.planner_type_get, _cffirmware.planner_type_set)
    reversed = property(_cffirmware.planner_reversed_get, _cffirmware.planner_reversed_set)
    trajectory = property(_cffirmware.planner_trajectory_get, _cffirmware.planner_trajectory_set)
    compressed_trajectory = property(_cffirmware.planner_compressed_trajectory_get, _cffirmware.planner_compressed_trajectory_set)
    planned_trajectory = property(_cffirmware.planner_planned_trajectory_get, _cffirmware.planner_planned_trajectory_set)
    pieces = property(_cffirmware.planner_pieces_get, _cffirmware.planner_pieces_set)

    def __init__(self):
        _cffirmware.planner_swiginit(self, _cffirmware.new_planner())
    __swig_destroy__ = _cffirmware.delete_planner

# Register planner in _cffirmware:
_cffirmware.planner_swigregister(planner)


def plan_init(p):
    return _cffirmware.plan_init(p)

def plan_stop(p):
    return _cffirmware.plan_stop(p)

def plan_is_stopped(p):
    return _cffirmware.plan_is_stopped(p)

def plan_current_goal(p, t):
    return _cffirmware.plan_current_goal(p, t)

def plan_takeoff(p, curr_pos, curr_yaw, hover_height, hover_yaw, duration, t):
    return _cffirmware.plan_takeoff(p, curr_pos, curr_yaw, hover_height, hover_yaw, duration, t)

def plan_land(p, curr_pos, curr_yaw, hover_height, hover_yaw, duration, t):
    return _cffirmware.plan_land(p, curr_pos, curr_yaw, hover_height, hover_yaw, duration, t)

def plan_go_to(p, relative, hover_pos, hover_yaw, duration, t):
    return _cffirmware.plan_go_to(p, relative, hover_pos, hover_yaw, duration, t)

def plan_go_to_from(p, curr_eval, relative, hover_pos, hover_yaw, duration, t):
    return _cffirmware.plan_go_to_from(p, curr_eval, relative, hover_pos, hover_yaw, duration, t)

def plan_start_trajectory(p, trajectory, reversed):
    return _cffirmware.plan_start_trajectory(p, trajectory, reversed)

def plan_start_compressed_trajectory(p, trajectory):
    return _cffirmware.plan_start_compressed_trajectory(p, trajectory)

def poly4d_set(poly, dim, coef, val):
    return _cffirmware.poly4d_set(poly, dim, coef, val)

def poly4d_get(poly, dim, coef):
    return _cffirmware.poly4d_get(poly, dim, coef)

def pp_get_piece(pp, i):
    return _cffirmware.pp_get_piece(pp, i)

def malloc_poly4d(size):
    return _cffirmware.malloc_poly4d(size)

import numpy as np



